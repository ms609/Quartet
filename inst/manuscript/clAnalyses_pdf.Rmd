---
title: "Precision and accuracy in Congreve & Lamsdell matrices"
author: "Martin R. Smith <martin.smith@durham.ac.uk>"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    toc: no
    includes:
      in_header: ../inst/preamble.tex
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/dependent/biology-letters.csl
link-citations: yes
github-repo: ms609/Quartet
vignette: >
  %\VignetteIndexEntry{Congreve & Lamsdell - individual trees}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This document depicts the analytical results of all 100 matrices generated by
Congreve & Lamsdell [-@Congreve2016] using a ternary plotting approach,
with quartets and partitions used as distance metrics.

```{r initialize, include=FALSE}
require('ape')
require('Ternary')
require('Quartet')
data('sq_trees')
n_tip <- 11
ref_tree <- sq_trees[[1]]
tip_colours <- Ternary::cbPalette15[-c(4, 7)] # Rm Tritanopia duplicates of 13 and 3
palette4 <- Ternary::cbPalette8[1:4]

PCH_MK <- 1   # circle
PCH_EQ <- 61  #'='
PCH_XX <- 183 #'.'
PCH_IW <- 3
PCH_IC <- 17  #triupfilled

COL_MK <- paste0(cbPalette8[4], '99')
COL_EQ <- paste0(cbPalette8[8], '99')
COL_1  <- paste0(cbPalette8[6], '42')
COL_2  <- paste0(cbPalette8[6], '42')
COL_3  <- paste0(cbPalette8[6], '42')
COL_5  <- paste0(cbPalette8[6], '99')
COL10  <- paste0(cbPalette8[6], '42')
COL_C  <- paste0(cbPalette8[2], '99')

GRID_COL <- rgb(0.92, 0.92, 0.92)
BG_COL   <- rgb(0.985, 0.985, 0.992)
GREY <- rgb(0.6, 0.6, 0.6)

Quartet2Ternary <- function (item, TREE) clQuartets[[item]][c('r2', 'd', 's'), , TREE]
  
Split2Ternary <- function (item, TREE) {
  itemData <- clPartitions[[item]][, , TREE]
  rbind(itemData['ref', ] - itemData['cf', ],
        itemData['cf_not_ref', ],
        itemData['cf_and_ref', ])
}

TernaryQuarts<-function(Func=Quartet2Ternary, TREE=TREE, zoom=1, padding=0.1) {
  
  xLim <- c(0, 1/zoom) - (0.1 / zoom)
  yLim <- c(0.5-(1/zoom), 0.5)
  lab <- if (zoom == 1) c('Unresolved quartets',
                          'Different quartets', 
                          'Identical quartets') else rep('', 3)
  
  TernaryPlot(NULL, NULL, NULL,
              lab[1], lab[2], lab[3], lab.cex=0.7,
              point='right',
              col=BG_COL,
              grid.lty='solid', grid.col=GRID_COL, grid.lines=19,
              grid.minor.lines=0,
              axis.labels = round(seq(0, choose(22, 4), length.out=20), 0),
              ticks.length = if (zoom == 1) 0.025 else 0.009,
              axis.col=rgb(0.6, 0.6, 0.6),
              padding=padding, xlim=xLim, ylim=yLim)
  HorizontalGrid(19)
  AddToTernary(lines, list(c(0, 2/3, 1/3), c(1, 0, 0)), lty='dotted', col=cbPalette8[8], lwd=2)
  
  JoinTheDots(Func('impliedC', TREE=TREE), col=COL_C,  pch=PCH_IC, cex=1.1)
  JoinTheDots(Func('implied10',TREE=TREE), col=COL10,  pch=PCH_IW, cex=1.1)
  JoinTheDots(Func('implied5', TREE=TREE), col=COL_5,  pch=PCH_IW, cex=1.1)
  JoinTheDots(Func('implied3', TREE=TREE), col=COL_3,  pch=PCH_IW, cex=1.1)
  JoinTheDots(Func('implied2', TREE=TREE), col=COL_2,  pch=PCH_IW, cex=1.1)
  JoinTheDots(Func('implied1', TREE=TREE), col=COL_1,  pch=PCH_IW, cex=1.1)
  JoinTheDots(Func('equal'   , TREE=TREE), col=COL_EQ, pch=PCH_EQ, cex=1.1)
  JoinTheDots(Func('markov'  , TREE=TREE), col=COL_MK, pch=PCH_MK, cex=1.1)
}

AddLegend <- function(pos='bottomright')
  legend(pos, cex=0.8, bty='n',
         lty=1,
         pch=c(PCH_MK, PCH_EQ, PCH_XX, PCH_IW, PCH_XX, PCH_XX, PCH_IW, PCH_IC), pt.cex=1.1,
         col=c(COL_MK, COL_EQ, COL10, COL_5, COL_3, COL_2, COL_1, COL_C),
         legend=c('Markov', 'Equal weights', paste0('Implied, k=', c(10, 5, 3, 2, 1, '2..10')))
  )

Plottem <- function (i) { 
  TREE <- i
  TernaryQuarts(TREE=TREE)
  mtext(text=paste0("\nDataset ", i, ": CI = ", round(clCI[i], 2)), 
        side=3, outer=TRUE, cex=1.2)
  arrows(sqrt(3/4) * 0.5, 0.5, sqrt(3/4) * 0.8, 0.5, length=0.1, col=GREY)
  text  (sqrt(3/4) * 0.65, 0.5, pos=3, 'Decreasing resolution', cex=0.8, col=GREY)
  
  arrows(sqrt(3/4) * 0.98, 0.40, sqrt(3/4) * 0.98, 0.20, length=0.1, col=GREY)
  text  (sqrt(3/4) * 1.01, 0.30, pos=3, 'Increasing divergence',
         cex=0.8, srt=270, col=GREY)
  
  rect(xleft=-0.03, ybottom=0.145, xright=0.31, ytop=0.52, border='#00000088', lty='dashed')
  
  TernaryQuarts(TREE=TREE, zoom=3, padding=0.01)
  
  TernaryPlot(NULL, NULL, NULL, 
              'Unresolved partitions', 'Different partitions',
              'Identical partitions', lab.cex=0.7, 
              point='right',
              col=BG_COL, 
              grid.lty='solid', grid.col=GRID_COL, grid.lines = 19,
              grid.minor.lines = 0, axis.labels = 0:19,
              axis.col=rgb(0.6, 0.6, 0.6), 
              padding=0.1)
  
  HorizontalGrid(19)
  partition_distances <- SplitsPoints(sq_trees)
  
  JoinTheDots(Split2Ternary('impliedC', TREE=TREE), col=COL_C, pch=PCH_IC, cex=1.1)
  JoinTheDots(Split2Ternary('implied10',TREE=TREE), col=COL10, pch=PCH_IW, cex=1.1)
  JoinTheDots(Split2Ternary('implied5', TREE=TREE), col=COL_5, pch=PCH_IW, cex=1.1)
  JoinTheDots(Split2Ternary('implied3', TREE=TREE), col=COL_3, pch=PCH_IW, cex=1.1)
  JoinTheDots(Split2Ternary('implied2', TREE=TREE), col=COL_2, pch=PCH_IW, cex=1.1)
  JoinTheDots(Split2Ternary('implied1', TREE=TREE), col=COL_1, pch=PCH_IW, cex=1.1)
  JoinTheDots(Split2Ternary('equal'  , TREE=TREE), col=COL_EQ, pch=PCH_EQ, cex=1.1)
  JoinTheDots(Split2Ternary('markov' , TREE=TREE), col=COL_MK, pch=PCH_MK, cex=1.1)
  
  arrows(sqrt(3/4) * 0.5, 0.5, sqrt(3/4) * 0.8, 0.5, length=0.1, col=GREY)
  text  (sqrt(3/4) * 0.65, 0.5, pos=3, 'Decreasing resolution', cex=0.8, col=GREY)
  
  arrows(sqrt(3/4) * 0.98, 0.40, sqrt(3/4) * 0.98, 0.20, length=0.1, col=GREY)
  text  (sqrt(3/4) * 1.01, 0.30, pos=3, 'Increasing RF distance',
         cex=0.8, srt=270, col=GREY)
  
  frame()
  AddLegend()
}
```

```{R ternary-diagrams, echo=FALSE, fig.width=7.2, fig.height=7.2}
par(mfrow=c(2, 2), mar=c(0.3, 0.3, 0.3, 0.3), oma=c(0, 0, 2, 0))
x <- lapply(1:100, Plottem)
```

## Reference