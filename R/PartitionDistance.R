#' Drop Single Splits
#' 
#' Removes splits that pertain only to a single taxon from a splits object
#' 
#' @param split A matrix in which each column corresponds to a bipartition split
#' 
#' @return The same matrix, with any columns that separate only a single pendant tip
#'         removed.
#'         
#' @author Martin R. Smith
#' 
#' @export 
DropSingleSplits <- function (split) {
  split[, colSums(split) > 1 & colSums(!split) > 1, drop=FALSE]
}

#' Tree2Splits
#' 
#' Converts a phylogenetic tree to an array of bipartition splits.
#' 
#' @param tr A tree of class \code{\link[ape:read.tree]{phylo}}, with tips bearing integer labels (i.e. tr$tip.label == 1:N).
#' @return Returns a two-dimensional array, with columns corresponding to bipartitions and rows corresponding
#' to tips 1:N.
#'
#' @author Martin R. Smith
#' 
#' @examples Tree2Splits(ape::rtree(6, tip.label=1:6, br=NULL))
#'
#' @importFrom ape reorder.phylo
#' @useDynLib Quartet, .registration = TRUE
#' @export
Tree2Splits <- function (tr) {
  tr <- reorder.phylo(tr, 'postorder')
  tip_label <- tr$tip.label
  n_tip <- as.integer(length(tip_label))
  root <- length(tip_label) + 1
  bipartitions <- phangorn_bipCPP(tr$edge, n_tip)
  ret <- vapply(bipartitions[-seq_len(root)], 
                function (x) seq_len(n_tip) %in% x, 
                logical(n_tip))[seq_len(n_tip), , drop=FALSE]
  rownames(ret) <- tip_label
  
  # Return:
  DropSingleSplits(ret)
}
#' @rdname Tree2Splits
Tree2Bipartitions <- Tree2Splits

#' Compare Splits
#' 
#' @param x A matrix of bipartitions, perhaps generated by \code{\link{Tree2Splits}}.
#' @param cf A matrix of bipartitions against which to compare \code{x}.
#' 
#' @return A vector of six integers, listing the number of splits that (1)
#'         are present in \code{x}; (2) are present in \code{cf}; (3) are
#'         present in both trees; (4) are present in \code{x} but not \code{cf};
#'         (5) are present in \code{cf} but not \code{x}; and (6) the sum of the
#'         latter two values, i.e. the Robinson-Foulds distance.
#'         
#' @references {
#'  \insertRef{Estabrook1985}{Quartet}
#'  \insertRef{Robinson1981}{Quartet}
#' }       
#' @author Martin R. Smith
#' @export
CompareSplits <- function (x, cf) {
  x <- DropSingleSplits(x)
  cf <- DropSingleSplits(cf)
  SplitHash <- function (split) {
    min(
      sum(2 ^ (which(split) - 1)),
      sum(2 ^ (which(!split) - 1))
    )
  }
  x_hashes <- unique(apply(x, 2, SplitHash))
  cf_hashes <- unique(apply(cf, 2, SplitHash))
  common <- sum(x_hashes %in% cf_hashes)
  x_splits <- length(x_hashes)
  cf_splits <- length(cf_hashes)
  c(x_splits, cf_splits, 
    common, x_splits - common, cf_splits - common,
    x_splits + cf_splits - (2 * common))
}
#' @rdname CompareSplits
CompareBipartitions <- CompareSplits

#' Matching partitions
#' 
#' Calculates how many of the partitions present in tree A are also present in 
#' tree B, how many of the partitions in tree A are absent in tree B, and how
#' many of the partitions in tree B are absent in tree A.  The Robinson-Foulds
#' (symmetric partition) distance is the sum of the latter two quantities.
#' 
#' @template treesParam
#' @template treesCfParam
#' 
#' @return Returns a two dimensional array. 
#'         Rows correspond to the input trees.
#'         Columns report the number of partitions that :
#'         1: are present in the comparison tree and the corresponding input tree;
#'         2: are unresolved in (at least) one of the comparison tree and the corresponding 
#'         input tree.
#'         
#'@seealso [QuartetStatus]
#'         
#' @examples{
#'  data('sq_trees')
#'  # Calculate the status of each quartet
#'  splitStatuses <- SplitStatus(sq_trees)
#'  
#'  # Extract just the Robinson Foulds distances
#'  splitStatuses[, 'RF_dist']
#'  
#'  # Normalize the Robinson Foulds distance by dividing by the number of 
#'  # splits (bipartitions) resolved in the reference tree:
#'  splitStatuses[, 'RF_dist'] / splitStatuses[, 'ref']
#'  
#'  # Normalize the Robinson Foulds distance by dividing by the total number of 
#'  # splits (bipartitions) that it is possible to resolve for `n` tips:
#'  nTip <- length(sq_trees[[1]]$tip.label)
#'  nPartitions <- (nTip - 3L) # Does not include the nTip partitions that 
#'                             # comprise but a single tip
#'  splitStatuses[, 'RF_dist'] / nPartitions
#'
#' }
#' 
#'  @references {
#'    \insertRef{Robinson1981}{Quartet}
#'    
#'    \insertRef{Penny1985}{Quartet}
#'  }
#' @author Martin R. Smith
#' @export
SplitStatus <- function (trees, cf=trees[[1]]) {
  if (!is.null(cf)) trees <- UnshiftTree(cf, trees)
  
  treeStats <- vapply(trees, function (tr)
    c(tr$Nnode, length(tr$tip.label)), double(2))
  if (length(unique(treeStats[2, ])) > 1) {
    stop("All trees must have the same number of tips")
  }
  tree1Labels <- trees[[1]]$tip.label
  trees <- lapply(trees, RenumberTips, tipOrder = tree1Labels)
  splits <- lapply(trees, Tree2Splits)
  ret <- vapply(splits, CompareSplits, cf=splits[[1]], double(6))
  rownames(ret) <- c('cf', 'ref',
                     'cf_and_ref', 'cf_not_ref', 'ref_not_cf',
                     'RF_dist')
  
  # Return:
  if (is.null(cf)) t(ret) else t(ret[, -1])
}

#' @rdname SplitStatus
#' @export
#' @keywords internal
BipartitionStatus <- SplitStatus
